#!/usr/bin/python3
# SPDX-License-Identifier: LGPL-2.1-or-later

import argparse
import signal
import sys
import time

from dasbus.typing import Variant
from dasbus.connection import AddressedMessageBus, InterfaceProxy, ObjectProxy
from dasbus.error import DBusError

from gi.repository import GLib
from typing import Any

OBJECT_PATH_BLUECHI = "/org/eclipse/bluechi/internal"
OBJECT_PATH_AGENT = OBJECT_PATH_BLUECHI + "/agent"

INTERFACE_BLUECHI = "org.eclipse.bluechi"
INTERFACE_AGENT = INTERFACE_BLUECHI + ".internal.Agent"

SUPPORTED_SIGNALS = ["JobDone"]  # format: ["SignalName1, SignalName2, etc"]


class BlueChiTester(object):

    def __init__(self, node_name: str) -> None:
        self.node_name: str = node_name
        self.peer_bus: AddressedMessageBus = None
        self.peer_bus_proxy: (InterfaceProxy | ObjectProxy | Any) = None

    def run(self,
            signal_name: str,
            num_signals: int):

        destination_bus_name = None

        number = 0
        while (num_signals == 0) or (number < num_signals):

            parameters = None
            if signal_name == "JobDone":
                parameters = Variant("(us)", (number, "fake-state"))

            self.peer_bus.connection.emit_signal(
                destination_bus_name,
                OBJECT_PATH_AGENT,
                INTERFACE_AGENT,
                signal_name,
                parameters
            )
            print(f"  * Sent {signal_name} {number}...")

            number += 1

        # wait a bit to ensure all signals are sent
        time.sleep(1)

    def connect_to_controller(
            self,
            url: str):
        self.peer_bus = AddressedMessageBus(f"{url}")
        self.peer_bus_proxy = self.peer_bus.get_proxy(
            INTERFACE_BLUECHI,
            OBJECT_PATH_BLUECHI
        )

        self.peer_bus_proxy.Register(self.node_name)


def main():
    parser = argparse.ArgumentParser(
        description="BlueChi Tester command-line arguments"
    )

    # Add command-line arguments
    parser.add_argument(
        "--nodename",
        required=True,
        type=str,
        help="Node name as a string"
    )

    parser.add_argument(
        "--numbersignals",
        type=int,
        default=10,
        help="Number of signals as an integer (default: 1). If 0 is passed, it will run infinitely."
    )

    parser.add_argument(
        "--signal",
        required=True,
        type=str,
        help="Signal as a string"
    )

    parser.add_argument(
        "--url",
        required=True,
        type=str,
        help="URL as a string")

    args = parser.parse_args()

    node_name = args.nodename
    num_signals = args.numbersignals
    signal_name = args.signal
    url = args.url

    # Print the values
    print(f"Node Name: {node_name}")
    print(f"Number of Signals: {num_signals}")
    print(f"Signal: {signal_name}")
    print(f"URL: {url}\n")

    if signal_name not in SUPPORTED_SIGNALS:
        supported_sigs = ' '.join(SUPPORTED_SIGNALS)
        print(f"Error: unsupported signal name, "
              f"use the following: {supported_sigs}")
        sys.exit(1)

    # Register handler for SIGINT
    def signal_handler(sig, frame):
        print('Aborting...')
        sys.exit(0)
    signal.signal(signal.SIGINT, signal_handler)

    BCAgent = BlueChiTester(node_name)

    try:
        BCAgent.connect_to_controller(url)
    except (GLib.GError, DBusError) as e:
        print(f"Unable to connect to BlueChi Controller: {e}")
        sys.exit(1)

    try:
        BCAgent.run(signal_name, num_signals)
    except (GLib.GError, DBusError) as e:
        print(f"Unable to send commands to BlueChi Controller: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
